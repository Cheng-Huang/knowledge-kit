# 深入理解各种锁

## 乐观锁、悲观锁

乐观锁对应于现实生活中乐观的人，思考事情总往好的方向发展；悲观锁对应于现实生活悲观的人，思考事情总往坏的方向发展。不同性格的人都有优缺点，不能抛开场景说一种人好而另一种人不好。

乐观锁和悲观锁是一种广义上的概念，体现了看待线程同步问题的不同角度，在 iOS、Java、数据库中都有此概念。

### 悲观锁
对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定会有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
这种线程一旦得到锁，其他需要锁的线程就挂起。共享资源每次只给一个线程使用，其他线程阻塞，用完再把资源转让给其他线程。传统的关系型数据库就用到很多悲观锁这种几只，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。

### 乐观锁

乐观锁认为自己在使用数据的时候不会有别的线程来修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果数据已经被别的线程更新，则根据不同方式执行不同操作（例如报错或者自动重试）。

可以根据版本号机制和 CAS 算法实现。

乐观锁适合多读少写的应用类型或者场景，即冲突真的很少发生的场景，这样省去了锁的开销，加大了系统的吞吐量。但是如果多写少读的情况，一般会经常发生冲突，这样会导致上层应用层不断 retry，这样反而降低了性能，所以一般建议多写的场景下使用悲观锁比较合适。


### 乐观锁常见的实现方式

乐观锁一般使用版本号机制或者 CAS 算法实现。

1. 版本号机制

在数据表增加一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时， version 值加1。当线程1更新数据的时候，先拿到数据并读取出 version 值，修改完数据进行提交更新的时候时，若读取出的 version 值为当前数据库中 version 值相等时才更新，否则重试更新操作，直到更新成功。


举个例子：
假设数据库中账户信息表有一个字段 version，值为1；当前账户余额为100。当需要对账户信息表进行更新的时候，需要读取 version 字段。


- [乐观锁和悲观锁的比较](https://blog.csdn.net/qq_34337272/article/details/81072874)
- [乐观锁的例子](https://www.jianshu.com/p/ae25eb3cfb5d)
- [大而全的锁概念](https://tech.meituan.com/2018/11/15/java-lock.html)